--- v4l-utils-1.22.1/utils/keytable/bpf_load.c.orig	2022-10-25 21:46:09.072545347 +0200
+++ v4l-utils-1.22.1/utils/keytable/bpf_load.c	2022-10-25 21:46:15.542510296 +0200
@@ -63,19 +63,21 @@ struct bpf_file {
 
 static int load_and_attach(int lirc_fd, struct bpf_file *bpf_file, struct bpf_insn *prog, int size)
 {
-	struct bpf_load_program_attr load_attr;
+	struct bpf_prog_load_opts load_opts;
 	int fd, err;
 
-	memset(&load_attr, 0, sizeof(struct bpf_load_program_attr));
+	memset(&load_opts, 0, sizeof(struct bpf_prog_load_opts));
 
-	load_attr.prog_type = BPF_PROG_TYPE_LIRC_MODE2;
-	load_attr.expected_attach_type = BPF_LIRC_MODE2;
-	load_attr.name = bpf_file->name;
-	load_attr.insns = prog;
-	load_attr.insns_cnt = size / sizeof(struct bpf_insn);
-	load_attr.license = bpf_file->license;
-
-	fd = bpf_load_program_xattr(&load_attr, bpf_log_buf, LOG_BUF_SIZE);
+	load_opts.sz = sizeof(struct bpf_prog_load_opts);
+	load_opts.expected_attach_type = BPF_LIRC_MODE2;
+	load_opts.log_size = LOG_BUF_SIZE;
+	load_opts.log_buf = bpf_log_buf;
+
+	fd = bpf_prog_load(BPF_PROG_TYPE_LIRC_MODE2,
+			   bpf_file->name,
+			   bpf_file->license,
+			   prog, size / sizeof(struct bpf_insn),
+			   &load_opts);
 	if (fd < 0) {
 		printf("bpf_load_program() err=%m\n%s", bpf_log_buf);
 		return -1;
@@ -95,6 +97,7 @@ static int build_raw_map(struct bpf_map_
 	int no_patterns, value_size, fd, key, i;
 	struct raw_entry *e;
 	struct raw_pattern *p;
+	struct bpf_map_create_opts map_opts;
 
 	no_patterns = 0;
 
@@ -110,13 +113,17 @@ static int build_raw_map(struct bpf_map_
 
 	value_size = sizeof(struct raw_pattern) + max_length * sizeof(short);
 
-	fd = bpf_create_map_node(map->def.type,
-				 map->name,
-				 map->def.key_size,
-				 value_size,
-				 no_patterns,
-				 map->def.map_flags,
-				 numa_node);
+	memset(&map_opts, 0, sizeof(struct bpf_map_create_opts));
+	map_opts.sz = sizeof(struct bpf_map_create_opts);
+	map_opts.map_flags = map->def.map_flags;
+	map_opts.numa_node = numa_node;
+
+	fd = bpf_map_create(map->def.type,
+			    map->name,
+			    map->def.key_size,
+			    value_size,
+			    no_patterns,
+			    &map_opts);
 
 	if (fd < 0) {
 		printf(_("failed to create a map: %d %s\n"),
@@ -167,6 +174,10 @@ static int load_maps(struct bpf_file *bp
 {
 	struct bpf_map_data *maps = bpf_file->map_data;
 	int i, numa_node;
+	struct bpf_map_create_opts map_opts;
+
+	memset(&map_opts, 0, sizeof(struct bpf_map_create_opts));
+	map_opts.sz = sizeof(struct bpf_map_create_opts);
 
 	for (i = 0; i < bpf_file->nr_maps; i++) {
 		numa_node = maps[i].def.map_flags & BPF_F_NUMA_NODE ?
@@ -174,27 +185,31 @@ static int load_maps(struct bpf_file *bp
 
 		if (maps[i].def.type == BPF_MAP_TYPE_ARRAY_OF_MAPS ||
 		    maps[i].def.type == BPF_MAP_TYPE_HASH_OF_MAPS) {
-			int inner_map_fd = bpf_file->map_fd[maps[i].def.inner_map_idx];
+			map_opts.inner_map_fd = bpf_file->map_fd[maps[i].def.inner_map_idx];
+			map_opts.map_flags = maps[i].def.map_flags;
+			map_opts.numa_node = numa_node;
 
-			bpf_file->map_fd[i] = bpf_create_map_in_map_node(
+			bpf_file->map_fd[i] = bpf_map_create(
 							maps[i].def.type,
 							maps[i].name,
 							maps[i].def.key_size,
-							inner_map_fd,
+							0,
 							maps[i].def.max_entries,
-							maps[i].def.map_flags,
-							numa_node);
+							&map_opts);
 		} else if (!strcmp(maps[i].name, "raw_map")) {
 			bpf_file->map_fd[i] = build_raw_map(&maps[i], raw, numa_node);
 		} else {
-			bpf_file->map_fd[i] = bpf_create_map_node(
+			map_opts.inner_map_fd = 0;
+			map_opts.map_flags = maps[i].def.map_flags;
+			map_opts.numa_node = numa_node;
+
+			bpf_file->map_fd[i] = bpf_map_create(
 							maps[i].def.type,
 							maps[i].name,
 							maps[i].def.key_size,
 							maps[i].def.value_size,
 							maps[i].def.max_entries,
-							maps[i].def.map_flags,
-							numa_node);
+							&map_opts);
 		}
 
 		if (bpf_file->map_fd[i] < 0) {
